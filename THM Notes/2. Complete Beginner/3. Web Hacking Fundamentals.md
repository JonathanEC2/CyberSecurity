
# How Websites Work

Front End (Client-Side) - the way your browser renders a website.
Back End (Server-Side) - a server that processes your request and returns a response.

## HTML

Websites are primarily created using:

- **HTML**, to build websites and define their structure
- **CSS**, to make websites look pretty by adding styling options
- **JavaScript**, implement complex features on pages using interactivity

## HTML Injection

HTML Injection is a vulnerability that occurs when unfiltered user input is displayed on the page.  

# HTTP in Detail

-  **HTTP** is the set of rules used for communicating with web servers for the transmission of webpage data, whether that is HTML, Images, Videos, etc.
-  A **URL** (Uniform Resource Locator)  is predominantly an instruction on how to access a resource on the internet.

## Requests And Responses

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXf__gYArIkIwQwP7V3VzTwCcrMkRRqxqBzmGbm7x9qiiD3HP_QryZeIg_K4WE_39DqlM0WrbdcFiUMiwmRf7ZHVQf5QHPP_tSfSWuM-Vr2PXPgVyet6nD79-Lh4bnyvO52i4XjG5ScAT2HSBHl8MmewdZmu?key=TfE_5MxENIjRvhHpOZCQ2w)

## HTTP Methods

HTTP methods are a way for the client to show their intended action when making an HTTP request.

- **GET** Request is used to get information from a web server.
- **POST** Request is used for submitting data to the web server and potentially creating new records
- **PUT** Request  is used for submitting data to a web server to update information
- **DELETE** Request is used to delete information/records from a web server.
 
## HTTP Status Codes

| 100-199 - Information Response | These are sent to tell the client the first part of their request has been accepted and they should continue sending the rest of their request. These codes are no longer very common. |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 200-299 - Success              | This range of status codes is used to tell the client their request was successful.                                                                                                    |
| 300-399 - Redirection          | These are used to redirect the client's request to another resource. This can be either to a different webpage or a different website altogether.                                      |
| 400-499 - Client Errors        | Used to inform the client that there was an error with their request.                                                                                                                  |
| 500-599 - Server Errors        | This is reserved for errors happening on the server-side and usually indicates quite a major problem with the server handling the request.                                             |

| 200 - OK                     | The request was completed successfully.                                                                                                                                                                                      |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 201 - Created                | A resource has been created (for example a new user or new blog post).                                                                                                                                                       |
| 301 - Moved Permanently      | This redirects the client's browser to a new webpage or tells search engines that the page has moved somewhere else and to look there instead.                                                                               |
| 302 - Found                  | Similar to the above permanent redirect, but as the name suggests, this is only a temporary change and it may change again in the near future.                                                                               |
| 400 - Bad Request            | This tells the browser that something was either wrong or missing in their request. This could sometimes be used if the web server resource that is being requested expects a certain parameter that the client didn't send. |
| 401 - Not Authorized         | You are not currently allowed to view this resource until you have authorized with the web application, most commonly with a username and password.                                                                          |
| 403 - Forbidden              | You do not have permission to view this resource whether you are logged in or not.                                                                                                                                           |
| 405 - Method Not Allowed     | The resource does not allow this method request, for example, you send a GET request to the resource /create-account when it was expecting a POST request instead.                                                           |
| 404 - Page Not Found         | The page/resource you requested does not exist.                                                                                                                                                                              |
| 500 - Internal Service Error | The server has encountered some kind of error with your request that it doesn't know how to handle properly.                                                                                                                 |
| 503 - Service Unavailable    | This server cannot handle your request as it's either overloaded or down for maintenance.                                                                                                                                    |

## Headers

Headers are additional bits of data you can send to the web server when making requests.

<font size = 4><b>Common Request Headers:</b></font>
- Host: by providing the host headers you can tell it which website you require, otherwise you'll just receive the default website for the server.
- User-Agent: This is your browser software and version number
- Content-Length: tells the web server how much data to expect in the web request. This way the server can ensure it isn't missing any data.
- Accept-Encoding: Tells the web server what types of compression methods the browser supports so the data can be made smaller for transmitting over the internet.
- Cookie: Data sent to the server to help remember your information

 <font size = 4><b>Common Response Headers:</b></font>
- Set-Cookie: Information to store which gets sent back to the web server on each request 
- Cache-Control: How long to store the content of the response in the browser's cache before it requests it again.
- Content-Type: This tells the client what type of data is being returned, i.e., HTML, CSS, JavaScript, Images, PDF, Video, etc. Using the content-type header the browser then knows how to process the data.
- Content-Encoding: What method has been used to compress the data to make it smaller when sending it over the internet.

## Cookies

Cookies are small pieces of data stored on your computer. Cookies are saved when you receive a "Set-Cookie" header from a web server. Because HTTP is stateless (doesn't keep track of your previous requests), cookies can be used to remind the web server who you are. Cookies are most commonly used for website authentication.

# Burp Suite: The Basics

 Burp Suite is a Java-based framework designed to serve as a comprehensive solution for conducting web application penetration testing. It is the industry standard tool for hands-on security assessments of web and mobile applications, including those that rely on application programming interfaces (APIs).


The Burp Dashboard is divided into four quadrants, as labeled in counter-clockwise order starting from the top left:


1. Tasks: The Tasks menu allows you to define background tasks that Burp Suite will perform while you use the application. In Burp Suite Community, the default “Live Passive Crawl” task, which automatically logs the pages visited, is sufficient for our purposes in this module. Burp Suite Professional offers additional features like on-demand scans.
2. Event log: The Event log provides information about the actions performed by Burp Suite, such as starting the proxy, as well as details about connections made through Burp.
3. Issue Activity: This section is specific to Burp Suite Professional. It displays the vulnerabilities identified by the automated scanner, ranked by severity and filterable based on the certainty of the vulnerability.
4. Advisory: The Advisory section provides more detailed information about the identified vulnerabilities, including references and suggested remediation's. This information can be exported into a report. In Burp Suite Community, this section may not show any vulnerabilities.


The Burp Proxy is a fundamental and crucial tool within Burp Suite. It enables the capture of requests and responses between the user and the target web server. This intercepted traffic can be manipulated, sent to other tools for further processing, or explicitly allowed to continue to its destination.

  
- When the proxy configuration is active, and the intercept is switched on in Burp Suite, your browser will hang whenever you make a request.
- Be cautious not to leave the intercept switched on unintentionally, as it can prevent your browser from making any requests.
- Right-clicking on a request in Burp Suite allows you to perform various actions, such as forwarding, dropping, sending to other tools, or selecting options from the right-click menu.
  

The Target tab

- Site map: This sub-tab allows us to map out the web applications we are targeting in a tree structure. Every page that we visit while the proxy is active will be displayed on the site map. 
- Issue definitions: provides an extensive list of web vulnerabilities, complete with descriptions and references. 
- Scope settings: This setting allows us to control the target scope in Burp Suite. It enables us to include or exclude specific domains/IPs to define the scope of our testing.

Scope

By setting a scope for the project, we can define what gets proxied and logged in Burp Suite. We can restrict Burp Suite to target only the specific web application(s) we want to test. The easiest way to do this is by switching to the Target tab, right-clicking on our target from the list on the left, and selecting Add To Scope. Burp will then prompt us to choose whether we want to stop logging anything that is not in scope, and in most cases, we want to select yes. 

The Scope settings window allows us to control our target scope by including or excluding domains/IPs. This section is powerful and worth spending time getting familiar with.

However, even if we disabled logging for out-of-scope traffic, the proxy will still intercept everything. To prevent this, we need to go to the Proxy settings sub-tab and select And URL Is in target scope from the "Intercept Client Requests" section.

Fortunately for us, client-side filters are absurdly easy to bypass. There are a variety of ways we could disable the script or just prevent it from loading in the first place.

With the request captured in the proxy, we can now change the email field to be our very simple payload from above: <script>alert("Succ3ssful XSS")</script>. After pasting in the payload, we need to select it, then URL encode it with the Ctrl + U shortcut to make it safe to send. 

To further enhance your skills, I encourage you to practice and experiment with Burp Suite. Explore its features, try different configurations, and familiarize yourself with its various tools. The more you use Burp Suite, the more proficient you will become in identifying and exploiting vulnerabilities in web applications.


## OWASP Top 10 - 2021

Open Web Application Security Project

  
1. Broken Access Control - allows attackers to bypass authorization, allowing them to view sensitive data or perform tasks they aren't supposed to.

	- IDOR or Insecure Direct Object Reference refers to an access control vulnerability where you can access resources you wouldn't ordinarily be able to see. 

2. Cryptographic Failures - any vulnerability arising from the misuse (or lack of use) of cryptographic algorithms for protecting sensitive information.
	
	- In a production environment, it is common to see databases set up on dedicated servers running a database service such as MySQL or MariaDB; however, databases can also be stored as files. These are referred to as "flat-file" databases, as they are stored as a single file on the computer.
	- The most common (and simplest) format of a flat-file database is an SQLite database. Sqlite3  dedicated client for querying flat-files

- To access db file, we use sqlite3 {database-name}
- From here, we can see the tables in the database by using the .tables command:
-  use PRAGMA table_info(table_name);
-  use SELECT * FROM table_name; to dump the information from the table:

3. Injection
    
	- SQL Injection: This occurs when user-controlled input is passed to SQL queries. As a result, an attacker can pass in SQL queries to manipulate the outcome of such queries. This could potentially allow the attacker to access, modify and delete information in a database when this input is passed into database queries.
	
	- Command Injection: This occurs when user input is passed to system commands. As a result, an attacker can execute arbitrary system commands on application servers, potentially allowing them to access users' systems.

4. Insecure Design
    
	- Insecure design refers to vulnerabilities that are inherent to the application's architecture. . They are not vulnerabilities regarding bad implementations or configurations, but the idea behind the whole application (or a part of it) is flawed from the start. 
  

5. Security Misconfiguration

	- Poorly configured permissions on cloud services, like S3 buckets.
	- Having unnecessary features enabled, like services, pages, accounts or privileges.
	- Default accounts with unchanged passwords.
	- Error messages that are overly detailed and allow attackers to find out more about the system.
	- Not using HTTP security headers.

6. Vulnerable and Outdated Components

	- If a company misses a single update for a program they use, it could be vulnerable to any number of attacks.
	-  It helps to understand the programming language the script is in so that, if needed, you can fix any bugs or make any modifications, as quite a few scripts on Exploit-DB expect you to make modifications.

7. Identification and Authentication Failures

	-  Authentication allows users to gain access to web applications by verifying their identities. 
	- Many times, developers forget to sanitize the input(username & password) given by the user in the code of their application, which can make them vulnerable to attacks like SQL injection.
	-  re-registration of an existing user

8. Software and Data Integrity Failures

	- When discussing integrity, we refer to the capacity to ascertain that a piece of data remains unmodified. Integrity is essential in cybersecurity as we care about maintaining important data free from unwanted or malicious modifications. 
	-  Usually, when a user logs into an application, they will be assigned some sort of session token that will need to be saved on the browser for as long as the session lasts. This token will be repeated on each subsequent request so that the web application knows who we are. These session tokens can come in many forms but are usually assigned via cookies. Cookies are key-value pairs that a web application will store on the user's browser and that will be automatically repeated on each request to the website that issued them.

- SEE LESSON FOR JWT ALGORITHM


9. Security Logging & Monitoring Failures

- Logging is important because, in the event of an incident, the attackers' activities can be traced. Once their actions are traced, their risk and impact can be determined. Without logging, there would be no way to tell what actions were performed by an attacker if they gain access to particular web applications.


10. Server-Side Request Forgery (SSRF)

	- This type of vulnerability occurs when an attacker can coerce a web application into sending requests on their behalf to arbitrary destinations while having control of the contents of the request itself.

  

## OWASP-Juice-Shop

SQL Injection

- The character ' will close the brackets in the SQL query
    
- 'OR' in a SQL statement will return true if either side of it is true. As 1=1 is always true, the whole statement is true. Thus it will tell the server that the email is valid, and log us into user id 0, which happens to be the administrator account.


  

Broken Authentication

- Check lab
    

  

Sensitive Data Exposure

- You will see that it links to  http://10.10.60.0/ftp/legal.md. Navigating to that /ftp/ directory reveals that it is exposed to the public!
    
-  But it seems we are met with a 403 which says that only .md and .pdf files can be downloaded. A Poison Null Byte is actually a NULL terminator. By placing a NULL character in the string at a certain byte, the string will tell the server to terminate at that point, nulling the rest of the string. 
    

  

Broken Access Control

- Horizontal Privilege Escalation - This occurs when a user can perform an action or access data of another user with the same level of permissions.
    
- Vertical Privilege Escalation - This occurs when a user can perform an action or access data of another user with a higher level of permissions.
    

  

Cross-Site Scripting XSS

- XSS or Cross-site scripting is a vulnerability that allows attackers to run javascript in web applications. These are some of the most found bugs in web applications.
    
- DOM (Special) - DOM XSS (Document Object Model-based Cross-site Scripting) uses the HTML environment to execute malicious javascript. This type of attack commonly uses the <script></script> HTML tag.
    
- Persistent (Server-side) - Persistent XSS is javascript that is run when the server loads the page containing it. These can occur when the server does not sanitize the user data when it is uploaded to a page. These are commonly found in blog posts. 
    
- Reflected (Client-side) - Reflected XSS is javascript that is run on the client-side end of the web application. These are most commonly found when the server doesn't sanitize search data. 
    

  

<iframe src="javascript:alert(`xss`)">  into the search bar

  

Note that we are using iframe which is a common HTML element found in many web applications, there are others that also produce the same result. This type of XSS, also called XFS (Cross-Frame Scripting), is one of the most common forms of detecting XSS within web applications. Websites that allow the user to modify the iframe or other DOM elements will most likely be vulnerable to XSS.   

  

## Upload Vulnerabilities

Overwriting files

- Looking at the source code for the page is good to see if any kind of client-side filtering is being applied. Scanning with a directory brute forcer such as Gobuster is usually helpful in web attacks, and may reveal where files are being uploaded to
    
- With a basic understanding of how the website might be handling our input, we can then try to poke around and see what we can and can't upload. If the website is employing client-side filtering then we can easily look at the code for the filter and look to bypass it. If the website has server-side filtering in place then we may need to guess what the filter is looking for, upload a file, then try something slightly different based on the error message if the upload fails. Uploading files designed to provoke errors can help with this. Tools like Burp Suite or OWASP Zap can be very helpful at this stage.
    

  

Remote Code Execution

- Remote Code Execution (as the name suggests) would allow us to execute code arbitrarily on the web server. y. Remote code execution via an upload vulnerability in a web application tends to be exploited by uploading a program written in the same language as the back-end of the website (or another language which the server understands and will execute). Traditionally this would be PHP, however, in more recent times, other back-end languages have become more common (Python Django and Javascript in the form of Node.js being prime examples). 
    
- There are two basic ways to achieve RCE on a webserver when exploiting a file upload vulnerability: webshells, and reverse/bind shells. Realistically a fully featured reverse/bind shell is the ideal goal for an attacker; however, a webshell may be the only option available
    

  

Filtering

- When we talk about a script being "Client-Side", in the context of web applications, we mean that it's running in the user's browser as opposed to on the web server itself. A client-side script will be run in your web browser. In the context of file-uploads, this means that the filtering occurs before the file is even uploaded to the server.  Because the filtering is happening on our computer, it is trivially easy to bypass.
    
- A server-side script will be run on the server. Traditionally PHP was the predominant server-side language. In recent years, other options (C#, Node.js, Python, Ruby on Rails, and a variety of others) have become more widely used. Server-side filtering tends to be more difficult to bypass, as you don't have the code in front of you. In most cases it will also be impossible to bypass the filter completely; instead we have to form a payload which conforms to the filters in place, but still allows us to execute our code.
    
- File length filters are used to prevent huge files from being uploaded to the server via an upload form
    
- File Name Filtering: As touched upon previously, files uploaded to a server should be unique. Usually this would mean adding a random aspect to the file name, however, an alternative strategy would be to check if a file with the same name already exists on the server, and give the user an error if so.  What this means for us is that, on a well administered system, our uploaded files are unlikely to have the same name we gave them before uploading, so be aware that you may have to go hunting for your shell in the event that you manage to bypass the content filtering.
    
- File Content Filtering More complicated filtering systems may scan the full contents of an uploaded file to ensure that it's not spoofing its extension, MIME type and Magic Number.
    

  

As mentioned previously, client-side filtering tends to be extremely easy to bypass, as it occurs entirely on a machine that you control. When you have access to the code, it's very easy to alter it.

  

There are four easy ways to bypass your average client-side file upload filter:

  

1. Turn off Javascript in your browser -- this will work provided the site doesn't require Javascript in order to provide basic functionality. If turning off Javascript completely will prevent the site from working at all then one of the other methods would be more desirable; otherwise, this can be an effective way of completely bypassing the client-side filter.
    
2. Intercept and modify the incoming page. Using Burpsuite, we can intercept the incoming web page and strip out the Javascript filter before it has a chance to run. The process for this will be covered below.
    

- Having established this, let's start Burpsuite and reload the page. We will see our own request to the site, but what we really want to see is the server's response, so right click on the intercepted data, scroll down to "Do Intercept", then select "Response to this request":
    
- When we click the "Forward" button at the top of the window, we will then see the server's response to our request. Here we can delete, comment out, or otherwise break the Javascript function before it has a chance to load:
    
- Having deleted the function, we once again click "Forward" until the site has finished loading, and are now free to upload any kind of file to the website:
    

3. Intercept and modify the file upload. Where the previous method works before the webpage is loaded, this method allows the web page to load as normal, but intercepts the file upload after it's already passed (and been accepted by the filter). Again, we will cover the process for using this method in the course of the task.
    

- Having reloaded the webpage to put the filter back in place, let's take the reverse shell that we used before and rename it to be called "shell.jpg". As the MIME type (based on the file extension) automatically checks out, the Client-Side filter lets our payload through without complaining:
    
- Once again we'll activate our Burpsuite intercept, then click "Upload" and catch the request:
    
- Observe that the MIME type of our PHP shell is currently image/jpeg. We'll change this to text/x-php, and the file extension from .jpg to .php, then forward the request to the server:
    

  

4. Send the file directly to the upload point. Why use the webpage with the filter, when you can send the file directly using a tool like curl? Posting the data directly to the page which contains the code for handling the file upload is another effective method for completely bypassing a client side filter. We will not be covering this method in any real depth in this tutorial, however, the syntax for such a command would look something like this: curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>. To use this method you would first aim to intercept a successful upload (using Burpsuite or the browser console) to see the parameters being used in the upload, which can then be slotted into the above command.
    

  
  

Server-Side

  

This is the really important point to take away from this task: there are a million different ways to implement the same feature when it comes to programming -- your exploitation must be tailored to the filter at hand. The key to bypassing any kind of server side filter is to enumerate and see what is allowed, as well as what is blocked; then try to craft a payload which can pass the criteria the filter is looking for.

  

There are a variety of different ways that this could be coded, and the bypass we use is dependent on that.

  

See if there is a different file type that can be uploaded. EX. php can use  .php3, .php4, .php5, .php7, .phps, .php-s, .pht and .phar

  

 Enumerate further, trying the techniques to get an idea of what the filter will accept or reject. Let's try uploading a file called shell.jpg.php. We already know that JPEG files are accepted, so what if the filter is just checking to see if the .jpg file extension is somewhere within the input?

  

As mentioned previously, magic numbers are used as a more accurate identifier of files. The magic number of a file is a string of hex digits, and is always the very first thing in a file. Knowing this, it's possible to use magic numbers to validate file uploads, simply by reading those first few bytes and comparing them against either a whitelist or a blacklist. Bear in mind that this technique can be very effective against a PHP based webserver; however, it can sometimes fail against other types of webserver (hint hint).

  

- Use the Linux file command to check the file type of our shell
    
- We can see that the magic number we've chosen is four bytes long, so let's open up the reverse shell script and add four random characters on the first line. These characters do not matter, so for this example we'll just use four "A"s:
    
- Save the file and exit. Next we're going to reopen the file in hexeditor (which comes by default on Kali)
    
- Change this to the magic number we found earlier for JPEG files: FF D8 FF DB
    
- Now if we save and exit the file (Ctrl + x), we can use file once again, and see that we have successfully spoofed the filetype of our shell
    

  

View page source code

Burp X-Powered by: 

Gobuster -x [file type] 

CTRL+f5 to clear cache

  

/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt

**