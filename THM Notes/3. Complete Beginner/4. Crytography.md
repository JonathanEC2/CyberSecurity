
# Hashing - Crypto 101

- **Plaintext** - Data before encryption or hashing, often text but not always as it could be a photograph or other file instead.
- <mark style="background: #FFF3A3A6;">**Encoding** - This is NOT a form of encryption, just a form of data representation like base64 or hexadecimal. Immediately reversible.</mark>
- **Hash** - A hash is the output of a hash function. Hashing can also be used as a verb, "to hash", meaning to produce the hash value of some data.
- **Brute** force - Attacking cryptography by trying every different password or every different key
- **Cryptanalysis** - Attacking cryptography by finding a weakness in the underlying maths


Hash functions are quite different from encryption. There is no key, and it’s meant to be impossible (or very very difficult) to go from the output back to the input.  Good hashing algorithms will be (relatively) fast to compute, and slow to reverse (Go from output and determine input).


Hash collision

Hashing is used for 2 main purposes in Cyber Security: To verify integrity of data or for verifying passwords. A rainbow table is a lookup table of hashes to plaintexts, so you can quickly find out what password a user had just from the hash.

Learn hashes yourself!! Use a healthy combination of context and tools!

On Linux, password hashes are stored in /etc/shadow. This file is normally only readable by root. On Windows, password hashes are stored in the SAM. Windows tries to prevent normal users from dumping them, but tools like mimikatz exist for this. Importantly, the hashes found there are split into NT hashes and LM hashes.

|                               |                                                            |
| ----------------------------- | ---------------------------------------------------------- |
| Prefix                        | Algorithm                                                  |
| $1$                           | md5crypt, used in Cisco stuff and older Linux/Unix systems |
| *$2$, $2a$, $2b$, $2x$, $2y$* | Bcrypt (Popular for web applications)                      |
| $6$                           | sha512crypt (Default for most Linux/Unix systems)          |

A great place to find more hash formats and password prefixes is the hashcat example page, available here: [https://hashcat.net/wiki/doku.php?id=example_hashes](https://hashcat.net/wiki/doku.php?id=example_hashes).For other hash types, you'll normally need to go by length, encoding or some research into the application that generated them. Never underestimate the power of research.

Graphics cards have thousands of cores. Although they can’t do the same sort of work that a CPU can, they are very good at some of the maths involved in hash functions. This means you can use a graphics card to crack most hash types much more quickly. It’s worth mentioning that virtual machines normally don’t have access to the host's graphics card(s). If you want to run hashcat, it’s best to run it on your host. . John the ripper uses CPU by default and as such, works in a VM out of the box although you may get better speeds running it on the host OS as it will have more threads and no overhead from running in a VM.

hashcat -m -a [hash file] [wordlist]

# John the Ripper

 A hash is a way of taking a piece of data of any length and  representing it in another form that is a fixed length. This masks the original value of the data. Hashing functions are designed as one-way functions. In other words, it is easy to calculate the hash value of a given input; however, it is a difficult problem to find the original input given the hash value. By "difficult", we mean that it is computationally infeasible.

  
Even though the algorithm itself is not feasibly reversible. That doesn't mean that cracking the hashes is impossible. If you have the hashed version of a password, for example- and you know the hashing algorithm- you can use that hashing algorithm to hash a large number of words, called a dictionary. You can then compare these hashes to the one you're trying to crack, to see if any of them match. If they do, you now know what word corresponds to that hash- you've cracked it!

john {OPTIONS}

john --wordlist={PATH_TO_PW_LIST}

hash-identifier, a Python tool that is super easy to use and will tell you what different types of hashes the one you enter is likely to be, giving you more options if the first one fails.\

Once you have identified the hash that you're dealing with, you can tell john to use it while cracking the provided hash using the following syntax:

john --format=[format] --wordlist=[path to wordlist] [path to file]

When you are telling john to use formats, if you're dealing with a standard hash type, e.g. md5 as in the example above, you have to prefix it with raw- to tell john you're just dealing with a standard hash type, though this doesn't always apply. To check if you need to add the prefix or not, you can list all of John's formats using john --list=formats and either check manually, or grep for your hash type using something like john --list=formats | grep -iF "md5".


Cracking Windows Authentication Hashes

Authentication hashes are the hashed versions of passwords that are stored by operating systems; it is sometimes possible to crack them using brute-force methods. To get your hands on these hashes, you must often already be a privileged user

You can acquire NTHash/NTLM hashes by dumping the SAM database on a Windows machine, by using a tool like Mimikatz or from the Active Directory database: NTDS.dit. You may not have to crack the hash to continue privilege escalation- as you can often conduct a "pass the hash" attack instead, but sometimes hash cracking is a viable option if there is a weak password policy.

  
Cracking /etc/shadow Hashes

The /etc/shadow file is the file on Linux machines where password hashes are stored. It also stores other information, such as the date of last password change and password expiration information. . This file is usually only accessible by the root user- so in order to get your hands on the hashes you must have sufficient privileges

John can be very particular about the formats it needs data in to be able to work with it, for this reason- in order to crack /etc/shadow passwords, you must combine it with the /etc/passwd file in order for John to understand the data it's being given. To do this, we use a tool built into the John suite of tools called unshadow. The basic syntax of unshadow is as follows:

unshadow {PATH_TO_PASSWORD}

  

Single Crack


Single Crack mode - In this mode, John uses only the information provided in the username, to try and work out possible passwords heuristically, by slightly changing the letters and numbers contained within the username.

Gecos -  /etc/shadow and /etc/passwd has fields separated by a colon ":". Each one of the fields that these records are split into are called Gecos fields. John can take information stored in those records, such as full name and home directory name to add in to the wordlist it generates when cracking /etc/shadow hashes with single crack mode

john --single --format=raw-sha256 hashes.txt


Cracking a Password Protected Zip File

Similarly to the unshadow tool that we used previously, we're going to be using the zip2john tool to convert the zip file into a hash format that John is able to understand, and hopefully crack. The basic usage is like this:

zip2john [options] [zip file] > [output file]

rar2john [rar file] > [output file]

  
Cracking SSH Key Passwords

Unless configured otherwise, you authenticate your SSH login using a password. However, you can configure key-based authentication, which lets you use your private key, id_rsa, as an authentication key to login to a remote machine over SSH.

ssh2john [id_rsa private key file] > [output file]

  

# Encryption - Crypto 101

There's a little bit of math(s) that comes up relatively often in cryptography. The Modulo operator. When learning division for the first time, you were probably taught to use remainders in your answer. X % Y is the remainder when X is divided by Y. An important thing to remember about modulo is that it’s not reversible. If I gave you an equation: x % 5 = 4, there are infinite values of x that will be valid.

  

RSA is based on the mathematically difficult problem of working out the factors of a large number. It’s very quick to multiply two prime numbers together, say 17*23 = 391, but it’s quite difficult to work out what two prime numbers multiply together to make 14351

  

The key variables that you need to know about for RSA in CTFs are p, q, m, n, e, d, and c.

  

- “p” and “q” are large prime numbers, “n” is the product of p and q.
    
- The public key is n and e, the private key is n and d.
    
- “m” is used to represent the message (in plaintext) and “c” represents the ciphertext (encrypted text).
    

  
  

SSH Private Keys

  

You should treat your private SSH keys like passwords. It’s very important to mention that the passphrase to decrypt the key isn’t used to identify you to the server at all, all it does is decrypt the SSH key. The passphrase is never transmitted, and never leaves your system. Using tools like John the Ripper, you can attack an encrypted SSH key to attempt to find the passphrase, which highlights the importance of using a secure passphrase and keeping your private key private.

  

When generating an SSH key to log in to a remote machine, you should generate the keys on your machine and then copy the public key over as this means the private key never exists on the target machine. The ~/.ssh folder is the default place to store these keys for OpenSSH. The authorized_keys  file in this directory holds public keys that are allowed to access the server if key authentication is enabled.

  

ssh -i keyNameGoesHere user@host is how you specify a key for the standard Linux OpenSSH client.

  

SSH keys are an excellent way to “upgrade” a reverse shell, assuming the user has login enabled .  Leaving an SSH key in authorized_keys on a box can be a useful backdoor

  

Key exchange allows 2 people/parties to establish a set of common cryptographic keys without an observer being able to get these keys. Generally, to establish common symmetric keys. DH Key Exchange is often used alongside RSA public key cryptography, to prove the identity of the person you’re talking to with digital signing.


PGP stands for Pretty Good Privacy. It’s a software that implements encryption for encrypting files, performing digital signing and more. GPG is an Open Source implementation of PGP from the GNU project. You may need to use GPG to decrypt files in CTFs. With PGP/GPG, private keys can be protected with passphrases in a similar way to SSH private keys. If the key is passphrase protected, you can attempt to crack this passphrase using John The Ripper and gpg2john.


  

